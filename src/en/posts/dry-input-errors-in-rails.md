---
title: DRY Input Errors in Rails
date: 2021-01-26
featured_image: /assets/img/articles/omar-nava-LGx6XzKYyv0-unsplash.jpg
featured_image_alt: Tatacoa desert, Colmobia
image_caption: <span>Photo by <a href="https://unsplash.com/@omar_nava?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Omar Nava</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>
description: DRY up your forms with a little Rails hook that will help you forget about conditionally rendering validation errors inline.
tags:
  - post
  - rails
  - forms
layout: layouts/post.njk
---

Spinning up a new Rails app has always been a joy to me. You can quickly scaffold your screens, setup your initial models and go straight to creating value and business logic. However, there's always a part where I feel like the framework doesn't quite do the entire job: form validation and error handling. There's one thing that I find specially difficult, and that is showing validation errors.

![description](/assets/img/articles/lM8pK46.png)

It would be much nicer if we could show each error next to the input that produced it. The downside here, is that now we'd have to replace this block of code generated by the scaffold with something else:

```erb
<div id="error_explanation">
  <h2><%= pluralize(model.errors.count, "error") %> prohibited this model from being saved:</h2>

  <ul>
    <% model.errors.each do |error| %>
      <li><%= error.full_message %></li>
    <% end %>
  </ul>
</div>
```

So how can we collocate our errors with their respective fields? We could render a `<p>`tag conditionally bellow the input field if there's any errors:

```erb
<%= form.label :email %>
<%= form.text_field :email %>
<%= tag.p user.errors["email"].join(", ") if user.errors["email"].any? %>
```

While this seems good enough for start, it quickly becomes a very repetitive task to add the error fields to every input. Furthermore, if you've ever used something like [Simple Form](https://github.com/heartcombo/simple_form) it feels like we're writing so much more code compared to:

```erb
<%= simple_form_for @user do |f| %>
  <%= f.input :email, label: 'Your email please', error: 'Email is mandatory, please specify one' %>
  <%= f.input :password, hint: 'No special characters.' %>
  <%= f.button :submit %>
<% end %>`
```

This snippet is doing a lot behind the scenes. It creates a label for our input, correctly infers the input type , conditionally renders errors below the input an even wraps it all up inside a dive so that your CSS can target the whole group.

However I did not want to bring in Simple Form into this project. The reasons for this might be worth looking into in another blog post, but mainly I feel like Simple Form plays better with a full fledged css framework like Bootstrap or Bulma and I'm using tailwind in this project. The second reason is that the form I was trying to build was a multi step form where I was creating a more complex layout than a wrapper `div` with a label and text input and it felt easier to write the html directly instead of passing classes through `wrapper:` `kwargs` for Simple Form.

## DRYing it up with a hook

Even if I didn't want all of Simple Form's functionality, conditionally rendering the model's validation errors seemed pretty useful to me so we could try to bring just that bit into our apps. Some googling around lead me to this great [blog post](https://www.jorgemanrubia.com/2019/02/16/form-validations-with-html5-and-modern-rails/) by Jorge Manrubia. From there, we could modify his initializer to render errors next to each field instead of at the top of the form.

```ruby
# Place this code in a initializer. E.g: config/initializers/field_error.rb

ActionView::Base.field_error_proc = Proc.new do |html_tag, instance_tag|
  fragment = Nokogiri::HTML.fragment(html_tag)
  field = fragment.at('input,select,textarea')

  html = if field
           error_message = instance_tag.error_message.join(', ')
           field['class'] = "#{field['class']} border-red-600 border focus:outline-none"
           html = <<-HTML
              #{fragment.to_s}
              <p class="mt-1 text-sm text-red-600">#{error_message.upcase_first}</p>
           HTML
           html
         else
           html_tag
         end

  html.html_safe
end
```

Since I had a bit of trouble understanding what was going on at first, I'll try to explain it here. This proc is called by Rails action view each time an ActiveModel field, that has validation errors, is rendered. This includes all kind of elements, including labels so the first thing we do is check if we're rendering an input that could have a validation error. If it's any other tag, we just render the html as is. Otherwise, we'll get all the error messagges from the field associated with the instance_tag (I was surprised to find out is exposed on it's public [api](https://api.rubyonrails.org/classes/ActionView/Helpers/ActiveModelInstanceTag.html#method-i-error_message)) and finally append our `<p>` tag with the proper styling and errors below the input.

## Closing thoughts

And there you go! Now we have automatically included a way to conditionally show validation errors on all of our forms without having to write a single line of code. I got to admit it felt a bit hacky at first, but so far I haven't really encountered any issues with this bit of logic and it pairs fairly well with server side validations. So what do you think? Is this a great or terrible idea? Let me know via email if you experiment with it and find any issues.
