---
title: DRY Input Errors in Rails
date: 2021-01-26
featured_image: /assets/img/articles/omar-nava-LGx6XzKYyv0-unsplash.jpg
featured_image_alt: Tatacoa desert, Colmobia
image_caption: <span>Photo by <a href="https://unsplash.com/@omar_nava?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Omar Nava</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>
description: DRY up your forms with a little Rails hook that will help you forget about conditionally rendering validation errors inline.
tags:
  - post
  - rails
  - forms
layout: layouts/post.njk
---

Spinning up a new Rails app has always been a joy to me. You can quickly scaffold your screens, setup your initial models and go straight to creating value and business logic. However, there's always a part where I feel like the framework doesn't quite do the entire job: form validation and error handling. There's one thing that I find specially difficult, and that is showing validation errors.

If you run Rails scaffold generator (which is great way to get going fast but not really intended for _production_ code), the form partial includes this snippet of code:

```erb
<div id="error_explanation">
  <h2><%= pluralize(model.errors.count, "error") %> prohibited this model from being saved:</h2>

  <ul>
    <% model.errors.each do |error| %>
      <li><%= error.full_message %></li>
    <% end %>
  </ul>
</div>
```

What it does is render an alert on top of the form wich contains the field name followed by the error message. Furthermore, since this bit of logic is fairly generic we could consider extracting it into it's own partial:

![description](/assets/img/articles/lM8pK46.png)

This technique is fine if your forms contain two or three inputs, but more than that it transfers the burden of mapping each error message to it's corresponding field to the user.

It would be clearer to show each error next to the input that produced it. To achieve this we'd have to delete this block of code generated by the scaffold with something else:

Unfurtunately,
So how can we collocate our errors with their respective fields? We could render a `<p>`tag conditionally bellow the input field if there's any errors:

```erb
<%= form.label :email %>
<%= form.text_field :email %>

<!-- Show Email validation errors -->
<%= tag.p user.errors["email"].join(", ") if user.errors["email"].any? %>
```

While this seems good enough for start, it quickly becomes a very repetitive task to add the error fields to every input. Furthermore, if you've ever used something like [Simple Form](https://github.com/heartcombo/simple_form) or [Formtastic](https://github.com/formtastic/formtastic) it feels like we're writing so much more code compared to:

```erb
<%= simple_form_for @user do |f| %>
  <%= f.input :email, label: 'Your email please', error: 'Email is mandatory, please specify one' %>
<% end %>`
```

This snippet is doing a lot behind the scenes. It creates a label for our input, correctly infers the input type , conditionally renders errors below the input an even wraps it all up inside a dive so that your CSS can target the whole group.

However I did not want to bring in Simple Form into this project for two reasons.

The first one is that Simple Form plays better with a full fledged css framework like Bootstrap or Bulma and I'm using tailwind in this project. Since I'm using [tailwind](https://tailwindcss.com) here I don't think utility css plays well with passing options through `keyword_args`. It makes it harder to understand the output HTML and I have't been able to make the intellisense + autocomplete work in my editor:

```erb
<%= simple_form_for @user do |f| %>
  <%= f.input :email,
   label: 'Your email please',
   error: 'Email is mandatory, please specify one',
   wrapper_html:  { class: "mt-2" },
   label_html:  { class: "font-semibold text-gray-800" },
   input_html:  { class: "border border-gray-800 rounded" },
   %>
<% end %>

<!-- vs -->

<%= form_for @user do |f| %>
  <div class="mt-2">
    <label for="user_email" class="font-semibold text-gray-800">Email</label>
    <%= f.input :email, class: "border border-gray-800 rounded" %>
  </div>
<% end %>
```

The second reason is a self-imposed rule to avoid bringing in gems if I only need a _small_ part of it's functionality and I could write it myself in a _reasonable_ amount of time.

## DRYing up error rendering with a hook

Even if I didn't want all of Simple Form's functionality, conditionally rendering the model's validation errors seemed pretty useful to me so we could try to bring just that bit into our apps. Some googling around lead me to this great [blog post](https://www.jorgemanrubia.com/2019/02/16/form-validations-with-html5-and-modern-rails/) by Jorge Manrubia. From there, we could modify his initializer to render errors next to each field instead of at the top of the form.

```ruby
# Place this code in a initializer. E.g: config/initializers/field_error.rb

ActionView::Base.field_error_proc = Proc.new do |html_tag, instance_tag|
  fragment = Nokogiri::HTML.fragment(html_tag)
  field = fragment.at('input,select,textarea')

  html = if field
           error_message = instance_tag.error_message.join(', ')
           field['class'] = "#{field['class']} border-red-600 border focus:outline-none"
           html = <<-HTML
              #{fragment.to_s}
              <p class="mt-1 text-sm text-red-600">#{error_message.upcase_first}</p>
           HTML
           html
         else
           html_tag
         end

  html.html_safe
end
```

Since I had a bit of trouble understanding what was going on at first, I'll try to explain it here. This proc is called by Rails action view each time an ActiveModel field, that has validation errors, is rendered. This includes all kind of elements, including labels so the first thing we do is check if we're rendering an input that could have a validation error. If it's any other tag, we just render the html as is. Otherwise, we'll get all the error messagges from the field associated with the instance_tag (I was surprised to find out is exposed on it's public [api](https://api.rubyonrails.org/classes/ActionView/Helpers/ActiveModelInstanceTag.html#method-i-error_message)) and finally append our `<p>` tag with the proper styling and errors below the input.

## Closing thoughts

And there you go! Now we have automatically included a way to conditionally show validation errors on all of our forms without having to write a single line of code. I got to admit it felt a bit hacky at first, but so far I haven't really encountered any issues with this bit of logic and it pairs fairly well with server side validations. So what do you think? Is this a great or terrible idea? Let me know via email if you experiment with it and find any issues.
